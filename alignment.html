<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>theanine-synthetase.alignment API documentation</title>
<meta name="description" content="The `alignment` module provides an implementation of the Needleman-Wunsch alignment algorithm." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>theanine-synthetase.alignment</code></h1>
</header>
<section id="section-intro">
<p>The <code>alignment</code> module provides an implementation of the Needleman-Wunsch alignment algorithm.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The `alignment` module provides an implementation of the Needleman-Wunsch alignment algorithm.&#34;&#34;&#34;

from typing import Tuple, Literal, List
from math import floor

import numpy as np

from stats import variance


MOVE_DIAGONAL = 0
MOVE_RIGHT = 1
MOVE_DOWN = 2
EditMove = Literal[MOVE_DIAGONAL, MOVE_RIGHT, MOVE_DOWN]


CHEMICAL_CLASS = {
    &#34;A&#34;: &#34;Purine&#34;,
    &#34;G&#34;: &#34;Purine&#34;,
    &#34;T&#34;: &#34;Pyrimidine&#34;,
    &#34;C&#34;: &#34;Pyrimidine&#34;,
}


class AlignmentResult:
    &#34;&#34;&#34;
    AlignmentResult represents the result of performing an alignment on two sequences.
    &#34;&#34;&#34;

    def __init__(self, alignment_1: str, alignment_2: str):
        &#34;&#34;&#34;
        Produces a new AlignmentResult representing the result of performing an alignment on
        two sequences.
        &#34;&#34;&#34;
        if len(alignment_1) != len(alignment_2):
            raise ValueError(&#34;input strings have differing lengths&#34;)
        self.alignment_1 = alignment_1
        self.alignment_2 = alignment_2

    def get_alignment_length(self) -&gt; int:
        &#34;&#34;&#34;Returns the length of the alignment.&#34;&#34;&#34;
        return len(self.alignment_1)

    def get_alignment_1(self) -&gt; str:
        &#34;&#34;&#34;Returns the first alignment string.&#34;&#34;&#34;
        return self.alignment_1

    def get_alignment_2(self) -&gt; str:
        &#34;&#34;&#34;Returns the second alignment string.&#34;&#34;&#34;
        return self.alignment_2

    def get_match_string(self) -&gt; str:
        &#34;&#34;&#34;Returns the match string for the alignment.&#34;&#34;&#34;
        return &#34;&#34;.join(
            [
                &#34;|&#34; if self.alignment_1[i] == self.alignment_2[i] else &#34; &#34;
                for i in range(len(self.alignment_1))
            ]
        )

    def clustered_mismatches(self, cluster_count: int) -&gt; List[int]:
        &#34;&#34;&#34;
        Breaks the alignment into `cluster_count` clusters and
        returns the number of mismatches in each cluster. If the
        alignment cannot be equally divided into the number of
        clusters, this leaves the last cluster with the remainder
        of the mismatches.
        &#34;&#34;&#34;
        if cluster_count &lt; 1:
            raise ValueError(&#34;cluster count must be greater than or equal to 1&#34;)

        match_string = self.get_match_string()

        cluster_size = floor(len(match_string) / cluster_count)

        return [
            match_string[i * cluster_size : i * cluster_size + cluster_size].count(&#34; &#34;)
            for i in range(0, len(match_string) // cluster_size)
        ]

    def clustered_mismatch_variance(self, cluster_count: int) -&gt; float:
        &#34;&#34;&#34;
        Returns the variance between the mismatch clusters. The
        raw cluster mismatches can be retrieved with the
        `clustered_mismatches` method. `cluster_count` controls
        the number of clusters used.
        &#34;&#34;&#34;
        return variance(
            np.array(self.clustered_mismatches(cluster_count=cluster_count)),
            sample=False,
        )

    def matches(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of matching elements for the alignment.&#34;&#34;&#34;
        return self.get_match_string().count(&#34;|&#34;)

    def hamming_distance(self) -&gt; int:
        &#34;&#34;&#34;Returns the Hamming distance of the alignment.&#34;&#34;&#34;
        return len(self.alignment_1) - self.matches()

    def largest_mismatch(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Returns the position and size of the largest mismatch in the alignment.&#34;&#34;&#34;
        matches = self.get_match_string()
        found_mismatch = False
        largest_mismatch = 0
        largest_mismatch_pos = 0
        current_mismatch = 0
        for i, c in enumerate(matches):
            if c == &#34; &#34;:
                found_mismatch = True
                current_mismatch += 1
                if current_mismatch &gt; largest_mismatch:
                    largest_mismatch = current_mismatch
                    largest_mismatch_pos = i - largest_mismatch + 1
            else:
                current_mismatch = 0
        if found_mismatch:
            return (largest_mismatch_pos, largest_mismatch)
        return (-1, 0)

    def format_result(self, line_length: int = 80):
        &#34;&#34;&#34;
        Formats the found alignment with pipes between
        matching elements. The optional `line_length` parameter
        allows for adjusting the number of elements on each set of
        lines.
        &#34;&#34;&#34;
        matches = self.get_match_string()

        # Chunk lines
        alignment_1_lines = [
            self.alignment_1[i : i + line_length]
            for i in range(0, len(self.alignment_1), line_length)
        ]
        alignment_2_lines = [
            self.alignment_2[i : i + line_length]
            for i in range(0, len(self.alignment_2), line_length)
        ]
        match_lines = [
            matches[i : i + line_length] for i in range(0, len(matches), line_length)
        ]

        # Output line chunks in order
        return &#34;\n&#34;.join(
            [
                &#34;\n&#34;.join(
                    [alignment_1_lines[i], match_lines[i], alignment_2_lines[i], &#34;&#34;]
                )
                for i in range(len(match_lines))
            ]
        )

    def examine(self, line_length: int = 80):
        &#34;&#34;&#34;
        Formats and prints the found alignment with pipes between
        matching elements. The optional `line_length` parameter
        allows for adjusting the number of elements on each set of
        lines.
        &#34;&#34;&#34;
        print(self.format_result(line_length=line_length))


def backtrack(quad: np.ndarray) -&gt; EditMove:
    &#34;&#34;&#34;Trace one step back through an edit matrix.&#34;&#34;&#34;
    if quad.shape == (0, 2):
        return MOVE_DOWN
    elif quad.shape == (2, 0):
        return MOVE_RIGHT

    # numpy&#39;s argmax doesn&#39;t allow for prioritizing non-indels
    next_pos = (0, 0)
    if quad[0, 1] &gt; quad[next_pos]:
        next_pos = (0, 1)
    if quad[1, 0] &gt; quad[next_pos]:
        next_pos = (1, 0)

    if next_pos == (0, 0):
        return MOVE_DIAGONAL
    elif next_pos == (0, 1):
        return MOVE_RIGHT
    else:
        return MOVE_DOWN


def score_cell(
    quad: np.ndarray,
    top_char: str,
    left_char: str,
    nucleotides: bool,
    chemical_classes: dict,
) -&gt; np.int:
    &#34;&#34;&#34;Calculate the Needleman-Wunsch score for a cell.&#34;&#34;&#34;
    down_score = quad[0, 1] - 1
    right_score = quad[1, 0] - 1

    # Penalize transversions more heavily
    if nucleotides and chemical_classes[top_char] != chemical_classes[left_char]:
        down_score -= 1
        right_score -= 1

    diag_score = quad[0, 0] - 1
    if top_char == left_char:
        diag_score += 2
    return max([down_score, right_score, diag_score])


def align_sequences(
    top_seq: str, left_seq: str, nucleotides: bool = True
) -&gt; AlignmentResult:
    &#34;&#34;&#34;
    This function aligns the two provided sequences using Needleman-Wunsch
    alignment. It uses a scoring scheme with a gap penalty of -1, a match
    bonus of 1, and a mismatch penalty of -1. If the two sequences are
    `nucleotides`, then an additional -1 penalty is applied to transversions.
    &#34;&#34;&#34;

    size1 = len(top_seq) + 1
    size2 = len(left_seq) + 1

    chemical_classes = CHEMICAL_CLASS  # Copy this into the local scope so it can be accessed more quickly

    # Build search matrix
    search = np.zeros((size2, size1), dtype=np.int)
    search[0] = [i for i in range(0, -size1, -1)]
    search[:, 0] = [i for i in range(0, -size2, -1)]

    # Do scoring
    for x in range(1, size2):
        for y in range(1, size1):
            search[x, y] = score_cell(
                search[x - 1 : x + 1, y - 1 : y + 1],
                top_seq[y - 1],
                left_seq[x - 1],
                nucleotides,
                chemical_classes,
            )
    search = search.T

    # Unwind result
    final_top = &#34;&#34;
    final_left = &#34;&#34;

    bt_x, bt_y = (size1 - 1, size2 - 1)
    while bt_x != 0 or bt_y != 0:
        next_move = backtrack(search[bt_x - 1 : bt_x + 1, bt_y - 1 : bt_y + 1])
        if next_move == MOVE_DIAGONAL:
            final_top = top_seq[bt_x - 1] + final_top
            final_left = left_seq[bt_y - 1] + final_left
            bt_x -= 1
            bt_y -= 1
        elif next_move == MOVE_DOWN:
            final_top = &#34;-&#34; + final_top
            final_left = left_seq[bt_y - 1] + final_left
            bt_y -= 1
        elif next_move == MOVE_RIGHT:
            final_top = top_seq[bt_x - 1] + final_top
            final_left = &#34;-&#34; + final_left
            bt_x -= 1

    return AlignmentResult(final_top, final_left)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="theanine-synthetase.alignment.align_sequences"><code class="name flex">
<span>def <span class="ident">align_sequences</span></span>(<span>top_seq: str, left_seq: str, nucleotides: bool = True) ‑> theanine-synthetase.alignment.AlignmentResult</span>
</code></dt>
<dd>
<div class="desc"><p>This function aligns the two provided sequences using Needleman-Wunsch
alignment. It uses a scoring scheme with a gap penalty of -1, a match
bonus of 1, and a mismatch penalty of -1. If the two sequences are
<code>nucleotides</code>, then an additional -1 penalty is applied to transversions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_sequences(
    top_seq: str, left_seq: str, nucleotides: bool = True
) -&gt; AlignmentResult:
    &#34;&#34;&#34;
    This function aligns the two provided sequences using Needleman-Wunsch
    alignment. It uses a scoring scheme with a gap penalty of -1, a match
    bonus of 1, and a mismatch penalty of -1. If the two sequences are
    `nucleotides`, then an additional -1 penalty is applied to transversions.
    &#34;&#34;&#34;

    size1 = len(top_seq) + 1
    size2 = len(left_seq) + 1

    chemical_classes = CHEMICAL_CLASS  # Copy this into the local scope so it can be accessed more quickly

    # Build search matrix
    search = np.zeros((size2, size1), dtype=np.int)
    search[0] = [i for i in range(0, -size1, -1)]
    search[:, 0] = [i for i in range(0, -size2, -1)]

    # Do scoring
    for x in range(1, size2):
        for y in range(1, size1):
            search[x, y] = score_cell(
                search[x - 1 : x + 1, y - 1 : y + 1],
                top_seq[y - 1],
                left_seq[x - 1],
                nucleotides,
                chemical_classes,
            )
    search = search.T

    # Unwind result
    final_top = &#34;&#34;
    final_left = &#34;&#34;

    bt_x, bt_y = (size1 - 1, size2 - 1)
    while bt_x != 0 or bt_y != 0:
        next_move = backtrack(search[bt_x - 1 : bt_x + 1, bt_y - 1 : bt_y + 1])
        if next_move == MOVE_DIAGONAL:
            final_top = top_seq[bt_x - 1] + final_top
            final_left = left_seq[bt_y - 1] + final_left
            bt_x -= 1
            bt_y -= 1
        elif next_move == MOVE_DOWN:
            final_top = &#34;-&#34; + final_top
            final_left = left_seq[bt_y - 1] + final_left
            bt_y -= 1
        elif next_move == MOVE_RIGHT:
            final_top = top_seq[bt_x - 1] + final_top
            final_left = &#34;-&#34; + final_left
            bt_x -= 1

    return AlignmentResult(final_top, final_left)</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.backtrack"><code class="name flex">
<span>def <span class="ident">backtrack</span></span>(<span>quad: numpy.ndarray) ‑> Literal[0, 1, 2]</span>
</code></dt>
<dd>
<div class="desc"><p>Trace one step back through an edit matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backtrack(quad: np.ndarray) -&gt; EditMove:
    &#34;&#34;&#34;Trace one step back through an edit matrix.&#34;&#34;&#34;
    if quad.shape == (0, 2):
        return MOVE_DOWN
    elif quad.shape == (2, 0):
        return MOVE_RIGHT

    # numpy&#39;s argmax doesn&#39;t allow for prioritizing non-indels
    next_pos = (0, 0)
    if quad[0, 1] &gt; quad[next_pos]:
        next_pos = (0, 1)
    if quad[1, 0] &gt; quad[next_pos]:
        next_pos = (1, 0)

    if next_pos == (0, 0):
        return MOVE_DIAGONAL
    elif next_pos == (0, 1):
        return MOVE_RIGHT
    else:
        return MOVE_DOWN</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.score_cell"><code class="name flex">
<span>def <span class="ident">score_cell</span></span>(<span>quad: numpy.ndarray, top_char: str, left_char: str, nucleotides: bool, chemical_classes: dict) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the Needleman-Wunsch score for a cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_cell(
    quad: np.ndarray,
    top_char: str,
    left_char: str,
    nucleotides: bool,
    chemical_classes: dict,
) -&gt; np.int:
    &#34;&#34;&#34;Calculate the Needleman-Wunsch score for a cell.&#34;&#34;&#34;
    down_score = quad[0, 1] - 1
    right_score = quad[1, 0] - 1

    # Penalize transversions more heavily
    if nucleotides and chemical_classes[top_char] != chemical_classes[left_char]:
        down_score -= 1
        right_score -= 1

    diag_score = quad[0, 0] - 1
    if top_char == left_char:
        diag_score += 2
    return max([down_score, right_score, diag_score])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="theanine-synthetase.alignment.AlignmentResult"><code class="flex name class">
<span>class <span class="ident">AlignmentResult</span></span>
<span>(</span><span>alignment_1: str, alignment_2: str)</span>
</code></dt>
<dd>
<div class="desc"><p>AlignmentResult represents the result of performing an alignment on two sequences.</p>
<p>Produces a new AlignmentResult representing the result of performing an alignment on
two sequences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlignmentResult:
    &#34;&#34;&#34;
    AlignmentResult represents the result of performing an alignment on two sequences.
    &#34;&#34;&#34;

    def __init__(self, alignment_1: str, alignment_2: str):
        &#34;&#34;&#34;
        Produces a new AlignmentResult representing the result of performing an alignment on
        two sequences.
        &#34;&#34;&#34;
        if len(alignment_1) != len(alignment_2):
            raise ValueError(&#34;input strings have differing lengths&#34;)
        self.alignment_1 = alignment_1
        self.alignment_2 = alignment_2

    def get_alignment_length(self) -&gt; int:
        &#34;&#34;&#34;Returns the length of the alignment.&#34;&#34;&#34;
        return len(self.alignment_1)

    def get_alignment_1(self) -&gt; str:
        &#34;&#34;&#34;Returns the first alignment string.&#34;&#34;&#34;
        return self.alignment_1

    def get_alignment_2(self) -&gt; str:
        &#34;&#34;&#34;Returns the second alignment string.&#34;&#34;&#34;
        return self.alignment_2

    def get_match_string(self) -&gt; str:
        &#34;&#34;&#34;Returns the match string for the alignment.&#34;&#34;&#34;
        return &#34;&#34;.join(
            [
                &#34;|&#34; if self.alignment_1[i] == self.alignment_2[i] else &#34; &#34;
                for i in range(len(self.alignment_1))
            ]
        )

    def clustered_mismatches(self, cluster_count: int) -&gt; List[int]:
        &#34;&#34;&#34;
        Breaks the alignment into `cluster_count` clusters and
        returns the number of mismatches in each cluster. If the
        alignment cannot be equally divided into the number of
        clusters, this leaves the last cluster with the remainder
        of the mismatches.
        &#34;&#34;&#34;
        if cluster_count &lt; 1:
            raise ValueError(&#34;cluster count must be greater than or equal to 1&#34;)

        match_string = self.get_match_string()

        cluster_size = floor(len(match_string) / cluster_count)

        return [
            match_string[i * cluster_size : i * cluster_size + cluster_size].count(&#34; &#34;)
            for i in range(0, len(match_string) // cluster_size)
        ]

    def clustered_mismatch_variance(self, cluster_count: int) -&gt; float:
        &#34;&#34;&#34;
        Returns the variance between the mismatch clusters. The
        raw cluster mismatches can be retrieved with the
        `clustered_mismatches` method. `cluster_count` controls
        the number of clusters used.
        &#34;&#34;&#34;
        return variance(
            np.array(self.clustered_mismatches(cluster_count=cluster_count)),
            sample=False,
        )

    def matches(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of matching elements for the alignment.&#34;&#34;&#34;
        return self.get_match_string().count(&#34;|&#34;)

    def hamming_distance(self) -&gt; int:
        &#34;&#34;&#34;Returns the Hamming distance of the alignment.&#34;&#34;&#34;
        return len(self.alignment_1) - self.matches()

    def largest_mismatch(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Returns the position and size of the largest mismatch in the alignment.&#34;&#34;&#34;
        matches = self.get_match_string()
        found_mismatch = False
        largest_mismatch = 0
        largest_mismatch_pos = 0
        current_mismatch = 0
        for i, c in enumerate(matches):
            if c == &#34; &#34;:
                found_mismatch = True
                current_mismatch += 1
                if current_mismatch &gt; largest_mismatch:
                    largest_mismatch = current_mismatch
                    largest_mismatch_pos = i - largest_mismatch + 1
            else:
                current_mismatch = 0
        if found_mismatch:
            return (largest_mismatch_pos, largest_mismatch)
        return (-1, 0)

    def format_result(self, line_length: int = 80):
        &#34;&#34;&#34;
        Formats the found alignment with pipes between
        matching elements. The optional `line_length` parameter
        allows for adjusting the number of elements on each set of
        lines.
        &#34;&#34;&#34;
        matches = self.get_match_string()

        # Chunk lines
        alignment_1_lines = [
            self.alignment_1[i : i + line_length]
            for i in range(0, len(self.alignment_1), line_length)
        ]
        alignment_2_lines = [
            self.alignment_2[i : i + line_length]
            for i in range(0, len(self.alignment_2), line_length)
        ]
        match_lines = [
            matches[i : i + line_length] for i in range(0, len(matches), line_length)
        ]

        # Output line chunks in order
        return &#34;\n&#34;.join(
            [
                &#34;\n&#34;.join(
                    [alignment_1_lines[i], match_lines[i], alignment_2_lines[i], &#34;&#34;]
                )
                for i in range(len(match_lines))
            ]
        )

    def examine(self, line_length: int = 80):
        &#34;&#34;&#34;
        Formats and prints the found alignment with pipes between
        matching elements. The optional `line_length` parameter
        allows for adjusting the number of elements on each set of
        lines.
        &#34;&#34;&#34;
        print(self.format_result(line_length=line_length))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="theanine-synthetase.alignment.AlignmentResult.clustered_mismatch_variance"><code class="name flex">
<span>def <span class="ident">clustered_mismatch_variance</span></span>(<span>self, cluster_count: int) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variance between the mismatch clusters. The
raw cluster mismatches can be retrieved with the
<code>clustered_mismatches</code> method. <code>cluster_count</code> controls
the number of clusters used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clustered_mismatch_variance(self, cluster_count: int) -&gt; float:
    &#34;&#34;&#34;
    Returns the variance between the mismatch clusters. The
    raw cluster mismatches can be retrieved with the
    `clustered_mismatches` method. `cluster_count` controls
    the number of clusters used.
    &#34;&#34;&#34;
    return variance(
        np.array(self.clustered_mismatches(cluster_count=cluster_count)),
        sample=False,
    )</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.clustered_mismatches"><code class="name flex">
<span>def <span class="ident">clustered_mismatches</span></span>(<span>self, cluster_count: int) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Breaks the alignment into <code>cluster_count</code> clusters and
returns the number of mismatches in each cluster. If the
alignment cannot be equally divided into the number of
clusters, this leaves the last cluster with the remainder
of the mismatches.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clustered_mismatches(self, cluster_count: int) -&gt; List[int]:
    &#34;&#34;&#34;
    Breaks the alignment into `cluster_count` clusters and
    returns the number of mismatches in each cluster. If the
    alignment cannot be equally divided into the number of
    clusters, this leaves the last cluster with the remainder
    of the mismatches.
    &#34;&#34;&#34;
    if cluster_count &lt; 1:
        raise ValueError(&#34;cluster count must be greater than or equal to 1&#34;)

    match_string = self.get_match_string()

    cluster_size = floor(len(match_string) / cluster_count)

    return [
        match_string[i * cluster_size : i * cluster_size + cluster_size].count(&#34; &#34;)
        for i in range(0, len(match_string) // cluster_size)
    ]</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.examine"><code class="name flex">
<span>def <span class="ident">examine</span></span>(<span>self, line_length: int = 80)</span>
</code></dt>
<dd>
<div class="desc"><p>Formats and prints the found alignment with pipes between
matching elements. The optional <code>line_length</code> parameter
allows for adjusting the number of elements on each set of
lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def examine(self, line_length: int = 80):
    &#34;&#34;&#34;
    Formats and prints the found alignment with pipes between
    matching elements. The optional `line_length` parameter
    allows for adjusting the number of elements on each set of
    lines.
    &#34;&#34;&#34;
    print(self.format_result(line_length=line_length))</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.format_result"><code class="name flex">
<span>def <span class="ident">format_result</span></span>(<span>self, line_length: int = 80)</span>
</code></dt>
<dd>
<div class="desc"><p>Formats the found alignment with pipes between
matching elements. The optional <code>line_length</code> parameter
allows for adjusting the number of elements on each set of
lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_result(self, line_length: int = 80):
    &#34;&#34;&#34;
    Formats the found alignment with pipes between
    matching elements. The optional `line_length` parameter
    allows for adjusting the number of elements on each set of
    lines.
    &#34;&#34;&#34;
    matches = self.get_match_string()

    # Chunk lines
    alignment_1_lines = [
        self.alignment_1[i : i + line_length]
        for i in range(0, len(self.alignment_1), line_length)
    ]
    alignment_2_lines = [
        self.alignment_2[i : i + line_length]
        for i in range(0, len(self.alignment_2), line_length)
    ]
    match_lines = [
        matches[i : i + line_length] for i in range(0, len(matches), line_length)
    ]

    # Output line chunks in order
    return &#34;\n&#34;.join(
        [
            &#34;\n&#34;.join(
                [alignment_1_lines[i], match_lines[i], alignment_2_lines[i], &#34;&#34;]
            )
            for i in range(len(match_lines))
        ]
    )</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.get_alignment_1"><code class="name flex">
<span>def <span class="ident">get_alignment_1</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first alignment string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alignment_1(self) -&gt; str:
    &#34;&#34;&#34;Returns the first alignment string.&#34;&#34;&#34;
    return self.alignment_1</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.get_alignment_2"><code class="name flex">
<span>def <span class="ident">get_alignment_2</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the second alignment string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alignment_2(self) -&gt; str:
    &#34;&#34;&#34;Returns the second alignment string.&#34;&#34;&#34;
    return self.alignment_2</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.get_alignment_length"><code class="name flex">
<span>def <span class="ident">get_alignment_length</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of the alignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alignment_length(self) -&gt; int:
    &#34;&#34;&#34;Returns the length of the alignment.&#34;&#34;&#34;
    return len(self.alignment_1)</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.get_match_string"><code class="name flex">
<span>def <span class="ident">get_match_string</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the match string for the alignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_match_string(self) -&gt; str:
    &#34;&#34;&#34;Returns the match string for the alignment.&#34;&#34;&#34;
    return &#34;&#34;.join(
        [
            &#34;|&#34; if self.alignment_1[i] == self.alignment_2[i] else &#34; &#34;
            for i in range(len(self.alignment_1))
        ]
    )</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.hamming_distance"><code class="name flex">
<span>def <span class="ident">hamming_distance</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Hamming distance of the alignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hamming_distance(self) -&gt; int:
    &#34;&#34;&#34;Returns the Hamming distance of the alignment.&#34;&#34;&#34;
    return len(self.alignment_1) - self.matches()</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.largest_mismatch"><code class="name flex">
<span>def <span class="ident">largest_mismatch</span></span>(<span>self) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the position and size of the largest mismatch in the alignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def largest_mismatch(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Returns the position and size of the largest mismatch in the alignment.&#34;&#34;&#34;
    matches = self.get_match_string()
    found_mismatch = False
    largest_mismatch = 0
    largest_mismatch_pos = 0
    current_mismatch = 0
    for i, c in enumerate(matches):
        if c == &#34; &#34;:
            found_mismatch = True
            current_mismatch += 1
            if current_mismatch &gt; largest_mismatch:
                largest_mismatch = current_mismatch
                largest_mismatch_pos = i - largest_mismatch + 1
        else:
            current_mismatch = 0
    if found_mismatch:
        return (largest_mismatch_pos, largest_mismatch)
    return (-1, 0)</code></pre>
</details>
</dd>
<dt id="theanine-synthetase.alignment.AlignmentResult.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of matching elements for the alignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches(self) -&gt; int:
    &#34;&#34;&#34;Returns the number of matching elements for the alignment.&#34;&#34;&#34;
    return self.get_match_string().count(&#34;|&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="theanine-synthetase" href="index.html">theanine-synthetase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="theanine-synthetase.alignment.align_sequences" href="#theanine-synthetase.alignment.align_sequences">align_sequences</a></code></li>
<li><code><a title="theanine-synthetase.alignment.backtrack" href="#theanine-synthetase.alignment.backtrack">backtrack</a></code></li>
<li><code><a title="theanine-synthetase.alignment.score_cell" href="#theanine-synthetase.alignment.score_cell">score_cell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="theanine-synthetase.alignment.AlignmentResult" href="#theanine-synthetase.alignment.AlignmentResult">AlignmentResult</a></code></h4>
<ul class="">
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.clustered_mismatch_variance" href="#theanine-synthetase.alignment.AlignmentResult.clustered_mismatch_variance">clustered_mismatch_variance</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.clustered_mismatches" href="#theanine-synthetase.alignment.AlignmentResult.clustered_mismatches">clustered_mismatches</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.examine" href="#theanine-synthetase.alignment.AlignmentResult.examine">examine</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.format_result" href="#theanine-synthetase.alignment.AlignmentResult.format_result">format_result</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.get_alignment_1" href="#theanine-synthetase.alignment.AlignmentResult.get_alignment_1">get_alignment_1</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.get_alignment_2" href="#theanine-synthetase.alignment.AlignmentResult.get_alignment_2">get_alignment_2</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.get_alignment_length" href="#theanine-synthetase.alignment.AlignmentResult.get_alignment_length">get_alignment_length</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.get_match_string" href="#theanine-synthetase.alignment.AlignmentResult.get_match_string">get_match_string</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.hamming_distance" href="#theanine-synthetase.alignment.AlignmentResult.hamming_distance">hamming_distance</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.largest_mismatch" href="#theanine-synthetase.alignment.AlignmentResult.largest_mismatch">largest_mismatch</a></code></li>
<li><code><a title="theanine-synthetase.alignment.AlignmentResult.matches" href="#theanine-synthetase.alignment.AlignmentResult.matches">matches</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>